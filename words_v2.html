<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ğŸ¤˜æ–·è©æ•´ç†å™¨ v2.0 - ç¾ä»£åŒ–æ¶æ§‹</title>
  <link rel="stylesheet" href="words.css" />
  <style>
    .module-status {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 12px;
      z-index: 1000;
    }
    .module-status.ready { background: rgba(0,128,0,0.8); }
    .module-status.loading { background: rgba(255,165,0,0.8); }
    .module-status.error { background: rgba(255,0,0,0.8); }
  </style>
</head>
<body>
    <div id="moduleStatus" class="module-status loading">è¼‰å…¥ä¸­...</div>
    
    <h2 id="pageTitle">ğŸ¤˜æ–·è©æ•´ç†å™¨ v2.0ğŸ¤˜</h2>
    <small><hr>ç¾ä»£åŒ–æ¨¡çµ„æ¶æ§‹ï¼Œé›¶é…ç½®è‡ªå‹•å„ªåŒ– <br>å¿«æ·éµ: Ctrl+Z å¾©åŸ, Ctrl+S ä¸‹è¼‰ <hr><a href="dictMaker_v2.html" target="dictMaker">å­—å…¸æ•´ç†å™¨ v2.0</a><hr></small>

    <div class="controls">
        <div id="encodingContainer" style="display: inline-block;"></div>
        
        <input type="file" id="openFileInput" accept=".txt,.md,.csv,.json,.log,.xml,.html,.htm,text/*" multiple style="display:none" />
        <button id="openFileBtn">é–‹å•Ÿæª”æ¡ˆ</button>
        
        <button id="simpleBtn">ç°¡æ˜“æ–·å¥+å»é‡</button>
        <button id="punctuationSortCountBtn">ç°¡æ˜“æ–·å¥+å»é‡è¨ˆæ•¸+æ’åº</button>
        
        <select id="sortOrderSelect" title="æ’åºæ–¹å¼">
          <option value="count" selected>è¨ˆæ•¸æ’åº</option>
          <option value="alpha">å­—æ¯æ’åº</option>
        </select>
        
        <select id="langFilterSelect">
          <option value="all">å…¨éƒ¨ï¼ˆä¸­ã€æ—¥ã€éŸ“ã€è‹±ï¼‰</option>
          <option value="zhen" selected>ä¸­è‹±æ–‡</option>
          <option value="cjk">ä¸­æ—¥éŸ“</option>
          <option value="zh">ç´”ä¸­æ–‡</option>
          <option value="en">ç´”è‹±æ–‡</option>
        </select>
        
        <button id="jiebaBtn"> æ–·è© </button>
        <button id="jiebaCustomBtn"> è‡ªè¨‚æ–·è© </button>
        <button id="PimeBtn"> å­—æ ¹å¾Œç½® (Pime è½‰ Rime)</button>
        <button id="RimeBtn"> Rime æ ¼å¼ {å­— å­— æ¬¡} </button>
        
        <input type="number" id="rimeBaseInput" value="3" min="1" max="9999" style="width: 60px; height:40px; margin-left: 8px;" title="åŸºæ•¸">
        
        <button id="freeCjBtn"> freeCj æ ¼å¼ </button>
        
        <span id="wordsCharOptions" style="margin-left: 8px;">è¼¸å‡ºè©çµ„å­—æ•¸ï¼š</span>
        
        <label style="margin-left: 8px;" title="è¼¸å‡ºé™æœ€å¤š5ç¢¼å­—æ ¹ (for PIMEå¿«å€‰)">
          <input type="checkbox" id="freeCjLimit5Checkbox" checked> é™5ç¢¼
        </label>
        
        <button id="nextStepBtn">â†è¼¸å‡ºè½‰è¼¸å…¥</button>
        <button id="undoBtn">å¾©åŸ</button>
    </div>

    <div id="textareaContainer"></div>
    
    <div id="statusContainer" style="margin: 12px 0;">
      <div id="excuted_result" style="color: green;">æ–·è©æ•´ç†å™¨ v2.0 å·²å°±ç·’</div>
      <div id="option_status" style="margin-top: 4px; font-size: 12px;"></div>
    </div>

<!-- è‡ªè¨‚è©å…¸æ¨¡æ…‹æ¡† -->
<div id="rovodevModalBackdrop" class="rovoModal-backdrop" style="display:none;"></div>
<div id="rovodevCustomDictModal" class="rovoModal-modal" style="display:none;">
  <div class="rovoModal-card">
    <div class="rovoModal-header">è‡ªè¨‚è©å…¸ï¼ˆJSON é™£åˆ—æˆ–é€—è™Ÿåˆ†éš”å­—ä¸²ï¼‰</div>
    <div class="rovoModal-body">
      <textarea id="customDictInput" placeholder='[["é€™å€‹", 99999999, "n"], ["å¸ƒä¸", 99999999, "n"]] æˆ– é€™å€‹,å¸ƒä¸,æ˜¯,åœ¨'></textarea>
      <div id="customDictError" class="rovoModal-error"></div>
    </div>
    <div class="rovoModal-footer">
      <button id="cancelCustomDictBtn" class="rovoModal-btn">å–æ¶ˆ</button>
      <button id="applyCustomDictBtn" class="rovoModal-btn primary">å¥—ç”¨ä¸¦æ–·è©</button>
    </div>
  </div>
</div>

<!-- ç¾ä»£åŒ–æ¨¡çµ„ç³»çµ± -->
<script src="scripts/jquery-3.7.1.slim.min.js"></script>
<script src="scripts/modules/core.js"></script>
<script src="scripts/modules/config.js"></script>
<script src="scripts/modules/cangjie.js"></script>
<script src="scripts/modules/charFilter.js"></script>
<script src="scripts/modules/ui.js"></script>
<script src="scripts/modules/app.js"></script>

<!-- Jieba æ–·è©æ”¯æ´ -->
<script src="scripts/require-jieba-js.js"></script>

<script>
// æ‡‰ç”¨ç¨‹å¼å•Ÿå‹•å™¨
$(async function() {
  const $status = $('#moduleStatus');
  
  try {
    $status.text('è¼‰å…¥æ¨¡çµ„ç³»çµ±...').removeClass().addClass('module-status loading');
    
    // åˆå§‹åŒ–æ¨¡çµ„ç³»çµ±
    const result = await ModuleSystem.init([
      'config', 'cangjie', 'charFilter', 'ui', 'app'
    ]);
    
    if (result.failed.length > 0) {
      console.warn('éƒ¨åˆ†æ¨¡çµ„è¼‰å…¥å¤±æ•—:', result.failed);
    }
    
    // ç²å–æ‡‰ç”¨ç¨‹å¼å¯¦ä¾‹
    const app = await ModuleSystem.get('app');
    const ui = await ModuleSystem.get('ui');
    const config = await ModuleSystem.get('config');
    
    // è¨­ç½®UIçµ„ä»¶
    ui.createEncodingSelect('#encodingContainer');
    ui.createDualTextareas('#textareaContainer', {
      inputPlaceholder: 'è«‹åœ¨æ­¤è¼¸å…¥æ–‡å­—...',
      showCounts: true
    });
    
    // ç¶å®šè‡ªè¨‚è©å…¸æ¨¡æ…‹æ¡†
    setupCustomDictModal();
    
    // ç¶å®šç°¡æ˜“è™•ç†æŒ‰éˆ•
    setupSimpleProcessing();
    
    // ç¶å®š Jieba ç›¸é—œæŒ‰éˆ•
    setupJiebaButtons();
    
    // ç¶å®šæ ¼å¼è½‰æ›æŒ‰éˆ•
    setupFormatButtons();
    
    // ç›£è½æ‡‰ç”¨ç¨‹å¼äº‹ä»¶
    app.on('appReady', (data) => {
      console.log('ğŸ‰ æ‡‰ç”¨ç¨‹å¼å·²å°±ç·’:', data);
      $status.text('v2.0 å·²å°±ç·’').removeClass().addClass('module-status ready');
    });
    
    // ç­‰å¾… Jieba è¼‰å…¥
    ensureJiebaReady();
    
    console.log('ğŸ”§ Words v2.0 é–‹ç™¼è€…å·¥å…·å·²è¼‰å…¥');
    
  } catch (error) {
    console.error('ğŸ’¥ æ‡‰ç”¨ç¨‹å¼å•Ÿå‹•å¤±æ•—:', error);
    $status.text('è¼‰å…¥å¤±æ•—').removeClass().addClass('module-status error');
    
    // é¡¯ç¤ºè©³ç´°éŒ¯èª¤ä¿¡æ¯
    $status.append(`<br><small>éŒ¯èª¤: ${error.message}</small>`);
    $status.append('<br><small>è«‹æª¢æŸ¥ç€è¦½å™¨æ§åˆ¶å°ä»¥ç²å–è©³ç´°ä¿¡æ¯</small>');
    $status.append('<br><small>5ç§’å¾Œå°‡æä¾›é¸é …...</small>');
    
    // çµ¦ç”¨æˆ¶é¸æ“‡
    setTimeout(() => {
      if (confirm('æ¨¡çµ„ç³»çµ±è¼‰å…¥å¤±æ•—ã€‚é»æ“Šç¢ºå®šè¼‰å…¥å‚³çµ±ç‰ˆæœ¬ï¼Œé»æ“Šå–æ¶ˆç•™åœ¨æ­¤é é¢é€²è¡Œèª¿è©¦ã€‚')) {
        window.location.href = 'words.html';
      } else {
        $status.text('å·²å–æ¶ˆè·³è½‰ï¼Œè«‹æŸ¥çœ‹æ§åˆ¶å°é€²è¡Œèª¿è©¦').removeClass().addClass('module-status error');
      }
    }, 5000);
  }
});

// è‡ªè¨‚è©å…¸æ¨¡æ…‹æ¡†
function setupCustomDictModal() {
  $('#jiebaCustomBtn').on('click', openCustomDictModal);
  $('#cancelCustomDictBtn, #rovodevModalBackdrop').on('click', closeCustomDictModal);
  $('#applyCustomDictBtn').on('click', applyCustomDict);
}

function openCustomDictModal() {
  let stored = localStorage.getItem('rovodev_custom_dict');
  let defaultDict;
  try { 
    defaultDict = stored ? JSON.parse(stored) : null; 
  } catch (_) { 
    defaultDict = null; 
  }
  
  if (!Array.isArray(defaultDict)) {
    defaultDict = [["ç¹ªè£½",99999999,"p"],["å»é‡",777777,"n"],["å¹«æˆ‘",666666,"n"]];
  }
  
  $('#customDictInput').val(JSON.stringify(defaultDict, null, 2));
  $('#customDictError').text('');
  $('#rovodevModalBackdrop, #rovodevCustomDictModal').show();
  setTimeout(() => $('#customDictInput').focus(), 0);
}

function closeCustomDictModal() {
  $('#rovodevModalBackdrop, #rovodevCustomDictModal').hide();
}

async function applyCustomDict() {
  const ui = await ModuleSystem.get('ui');
  
  try {
    const input = $('#customDictInput').val();
    const customDict = parseCustomDict(input);
    
    if (!customDict.length) {
      throw new Error('è‡ªè¨‚è©å…¸ç‚ºç©º');
    }
    
    localStorage.setItem('rovodev_custom_dict', JSON.stringify(customDict));
    
    const text = $('#inputTextarea').val();
    if (!text.trim()) {
      ui.showStatus('è«‹å…ˆè¼¸å…¥æ–‡å­—', 'warning');
      return;
    }
    
    if (typeof call_jieba_cut === 'function') {
      call_jieba_cut(text, customDict, tokens => {
        ui.setOutput(tokens.join(' '), 'jiebaCustom');
        closeCustomDictModal();
      });
    } else {
      ui.showStatus('Jieba æ–·è©å‡½å¼æœªè¼‰å…¥', 'error');
    }
    
  } catch (error) {
    $('#customDictError').text(error.message);
    ui.showStatus('è‡ªè¨‚è©å…¸è™•ç†å¤±æ•—: ' + error.message, 'error');
  }
}

function parseCustomDict(input) {
  if (!input) return [];
  const s = String(input).trim();
  
  try {
    const arr = JSON.parse(s);
    if (Array.isArray(arr)) return arr;
  } catch (_) {}
  
  const tokens = s.split(/[,\s]+/).map(t=>t.trim()).filter(Boolean);
  return tokens.map(w => [w, 99999999, 'n']);
}

// ç°¡æ˜“è™•ç†
function setupSimpleProcessing() {
  $('#simpleBtn').on('click', async () => {
    const ui = await ModuleSystem.get('ui');
    const text = prepare('dedup');
    ui.setOutput(text, 'ç°¡æ˜“æ–·å¥å»é‡');
  });

  $('#punctuationSortCountBtn').on('click', async () => {
    const ui = await ModuleSystem.get('ui');
    const words = prepare('[]');
    const wordCounts = words.reduce((acc, word) => {
      acc[word] = (acc[word] || 0) + 1;
      return acc;
    }, {});

    const sortOrder = $('#sortOrderSelect').val();
    let sortedWords;

    if (sortOrder === 'alpha') {
      sortedWords = Object.entries(wordCounts)
        .sort(([wordA], [wordB]) => wordB.localeCompare(wordA))
        .map(([word, count]) => `${word}\t${count}`);
    } else {
      sortedWords = Object.entries(wordCounts)
        .sort(([, countA], [, countB]) => countB - countA)
        .map(([word, count]) => `${word}\t${count}`);
    }

    ui.setOutput(sortedWords.join('\n'), 'punctuationSortCount');
  });
}

// Jieba æŒ‰éˆ•
function setupJiebaButtons() {
  $('#jiebaBtn').on('click', async () => {
    const ui = await ModuleSystem.get('ui');
    
    if (!checkJieba()) return;
    
    const txt = $('#inputTextarea').val();
    if (txt) {
      call_jieba_cut(txt, res => ui.setOutput(res.join(' '), 'jieba'));
    }
  });
}

// æ ¼å¼è½‰æ›æŒ‰éˆ•  
function setupFormatButtons() {
  $('#PimeBtn').on('click', async () => {
    const ui = await ModuleSystem.get('ui');
    const config = await ModuleSystem.get('config');
    
    const base = config.get('words.rimeBase', 3);
    const src = $('#inputTextarea').val();
    
    const result = (src || '')
      .replace(/^([a-z]+) (\S+)/g, `$2\t$1\t${base}`)
      .replace(/\n([a-z]+) (\S+)/g, `\n$2\t$1\t${base}`);
    
    ui.setOutput(result, 'pime');
  });

  $('#RimeBtn').on('click', async () => {
    const ui = await ModuleSystem.get('ui');
    const config = await ModuleSystem.get('config');
    
    const txt = prepare('dedup');
    const base = config.get('words.rimeBase', 3);
    
    if (txt && checkJieba()) {
      call_jieba_cut(txt, res => ui.setOutput(toRime(res.join('\n'), base), 'rime'));
    } else {
      ui.setOutput(toRime(txt, base), 'rime');
    }
  });
}

// å·¥å…·å‡½æ•¸
function prepare(returnType = '') {
  const txt = $('#inputTextarea').val() || '';
  if (!txt.trim()) return returnType.includes('[]') ? [] : '';
  
  const filtered = langFiltering(txt);
  const arr = filtered.split(/\s+/).filter(Boolean);
  
  if (returnType.includes('dedup')) {
    return [...new Set(arr)].join('\n');
  }
  
  return returnType.includes('[]') ? arr : arr.join('\n');
}

function langFiltering(txt) {
  const filterType = $('#langFilterSelect').val();
  const zh = '\u4e00-\u9fff';
  const jp = '\u3040-\u309f\u30a0-\u30ff';
  const kr = '\uac00-\ud7af';
  const en = 'a-zA-Z';
  
  let pattern;
  switch (filterType) {
    case 'all': pattern = `${zh}${jp}${kr}${en}`; break;
    case 'cjk': pattern = `${zh}${jp}${kr}`; break;
    case 'zh': pattern = zh; break;
    case 'en': pattern = en; break;
    default: pattern = `${zh}${en}`;
  }
  
  const regex = new RegExp(`[^${pattern}]`, 'g');
  return txt.replace(regex, ' ');
}

function toRime(w, base = 3) {
  return w.split('\n').filter(l=>l.trim()).map(l=>`${l}\t${l}\t${base}`).join('\n');
}

function checkJieba() {
  const ok = typeof call_jieba_cut !== 'undefined';
  if (!ok) {
    ModuleSystem.get('ui').then(ui => 
      ui.showStatus('Jieba æ–·è©å‡½å¼æœªè¼‰å…¥ï¼Œè«‹ç¨å€™ã€‚', 'warning')
    );
  }
  return ok;
}

function ensureJiebaReady() {
  let tries = 100;
  const tick = () => {
    if (typeof call_jieba_cut === 'function') {
      $('#pageTitle').css({ borderColor: '#0F0' });
      if (typeof resume_jieba_cut === 'function') {
        try { resume_jieba_cut(); } catch (e) { console.warn('resume error', e); }
      }
    } else if (tries-- > 0) {
      setTimeout(tick, 100);
    } else {
      console.warn('Jieba not ready after waiting');
    }
  };
  tick();
}

// å¿«æ·éµæ”¯æ´
$(document).on('keydown', function(e) {
  if (e.ctrlKey || e.metaKey) {
    switch(e.key) {
      case 'z':
        e.preventDefault();
        $('#undoBtn').click();
        break;
      case 's':
        e.preventDefault();
        ModuleSystem.get('ui').then(ui => ui.downloadOutput());
        break;
    }
  }
});
</script>

</body>
</html>